{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///Users/sudhir/Documents/vibe/error-saas/lib/mongodb.ts"],"sourcesContent":["import { MongoClient } from 'mongodb'\n\nif (!process.env.MONGODB_URI) {\n  throw new Error('Invalid/Missing environment variable: \"MONGODB_URI\"')\n}\n\nconst uri = process.env.MONGODB_URI\nconst options = {}\n\nlet client: MongoClient\nlet clientPromise: Promise<MongoClient>\n\nif (process.env.NODE_ENV === 'development') {\n  // In development mode, use a global variable so that the value\n  // is preserved across module reloads caused by HMR (Hot Module Replacement).\n  let globalWithMongo = global as typeof globalThis & {\n    _mongoClientPromise?: Promise<MongoClient>\n  }\n\n  if (!globalWithMongo._mongoClientPromise) {\n    client = new MongoClient(uri, options)\n    globalWithMongo._mongoClientPromise = client.connect()\n  }\n  clientPromise = globalWithMongo._mongoClientPromise\n} else {\n  // In production mode, it's best to not use a global variable.\n  client = new MongoClient(uri, options)\n  clientPromise = client.connect()\n}\n\nexport default clientPromise"],"names":[],"mappings":";;;;AAAA;;AAEA,IAAI,CAAC,QAAQ,GAAG,CAAC,WAAW,EAAE;IAC5B,MAAM,IAAI,MAAM;AAClB;AAEA,MAAM,MAAM,QAAQ,GAAG,CAAC,WAAW;AACnC,MAAM,UAAU,CAAC;AAEjB,IAAI;AACJ,IAAI;AAEJ,wCAA4C;IAC1C,+DAA+D;IAC/D,6EAA6E;IAC7E,IAAI;IAIJ,IAAI,CAAC,gBAAgB,mBAAmB,EAAE;QACxC,SAAS,IAAI,sHAAW,CAAC,KAAK;QAC9B,gBAAgB,mBAAmB,GAAG,OAAO,OAAO;IACtD;IACA,gBAAgB,gBAAgB,mBAAmB;AACrD;;uCAMe"}},
    {"offset": {"line": 81, "column": 0}, "map": {"version":3,"sources":["file:///Users/sudhir/Documents/vibe/error-saas/lib/schema.ts"],"sourcesContent":["import { z } from 'zod'\n\n// Source schema for linking to documentation\nconst SourceSchema = z.object({\n  url: z.string().url(),\n  label: z.string()\n})\n\n// Error document schema as specified in master.md\nexport const ErrorSchema = z.object({\n  tool: z.literal(\"kubernetes\"),\n  canonical_slug: z.string(),\n  title: z.string(),\n  aliases: z.array(z.string()),\n  matchers: z.object({\n    regex: z.array(z.string())\n  }),\n  category: z.enum([\"registry\", \"auth\", \"network\", \"storage\", \"scheduling\", \"runtime\", \"config\", \"unknown\", \"scheduler\", \"cluster\"]),\n  summary: z.string(),\n  root_causes: z.array(z.object({\n    name: z.string(),\n    why: z.string(),\n    confidence: z.number().min(0).max(1),\n    sources: z.array(SourceSchema)\n  })),\n  fix_steps: z.array(z.object({\n    step: z.string(),\n    commands: z.array(z.string()),\n    sources: z.array(SourceSchema)\n  })),\n  clarifying_questions: z.array(z.string()),\n  examples: z.array(z.object({\n    name: z.string(),\n    symptom: z.string(),\n    fix: z.string(),\n    sources: z.array(SourceSchema)\n  })),\n  created_at: z.string(),\n  updated_at: z.string()\n})\n\n// Submission schema for tracking user inputs\nexport const SubmissionSchema = z.object({\n  raw_text: z.string(),\n  normalized_text: z.string(),\n  matched_slug: z.string().nullable(),\n  matched_confidence: z.number(),\n  created_at: z.string()\n})\n\nexport type KubernetesError = z.infer<typeof ErrorSchema>\nexport type Submission = z.infer<typeof SubmissionSchema>\nexport type Source = z.infer<typeof SourceSchema>"],"names":[],"mappings":";;;;;;AAAA;;AAEA,6CAA6C;AAC7C,MAAM,eAAe,8PAAC,CAAC,MAAM,CAAC;IAC5B,KAAK,8PAAC,CAAC,MAAM,GAAG,GAAG;IACnB,OAAO,8PAAC,CAAC,MAAM;AACjB;AAGO,MAAM,cAAc,8PAAC,CAAC,MAAM,CAAC;IAClC,MAAM,8PAAC,CAAC,OAAO,CAAC;IAChB,gBAAgB,8PAAC,CAAC,MAAM;IACxB,OAAO,8PAAC,CAAC,MAAM;IACf,SAAS,8PAAC,CAAC,KAAK,CAAC,8PAAC,CAAC,MAAM;IACzB,UAAU,8PAAC,CAAC,MAAM,CAAC;QACjB,OAAO,8PAAC,CAAC,KAAK,CAAC,8PAAC,CAAC,MAAM;IACzB;IACA,UAAU,8PAAC,CAAC,IAAI,CAAC;QAAC;QAAY;QAAQ;QAAW;QAAW;QAAc;QAAW;QAAU;QAAW;QAAa;KAAU;IACjI,SAAS,8PAAC,CAAC,MAAM;IACjB,aAAa,8PAAC,CAAC,KAAK,CAAC,8PAAC,CAAC,MAAM,CAAC;QAC5B,MAAM,8PAAC,CAAC,MAAM;QACd,KAAK,8PAAC,CAAC,MAAM;QACb,YAAY,8PAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAAG,GAAG,CAAC;QAClC,SAAS,8PAAC,CAAC,KAAK,CAAC;IACnB;IACA,WAAW,8PAAC,CAAC,KAAK,CAAC,8PAAC,CAAC,MAAM,CAAC;QAC1B,MAAM,8PAAC,CAAC,MAAM;QACd,UAAU,8PAAC,CAAC,KAAK,CAAC,8PAAC,CAAC,MAAM;QAC1B,SAAS,8PAAC,CAAC,KAAK,CAAC;IACnB;IACA,sBAAsB,8PAAC,CAAC,KAAK,CAAC,8PAAC,CAAC,MAAM;IACtC,UAAU,8PAAC,CAAC,KAAK,CAAC,8PAAC,CAAC,MAAM,CAAC;QACzB,MAAM,8PAAC,CAAC,MAAM;QACd,SAAS,8PAAC,CAAC,MAAM;QACjB,KAAK,8PAAC,CAAC,MAAM;QACb,SAAS,8PAAC,CAAC,KAAK,CAAC;IACnB;IACA,YAAY,8PAAC,CAAC,MAAM;IACpB,YAAY,8PAAC,CAAC,MAAM;AACtB;AAGO,MAAM,mBAAmB,8PAAC,CAAC,MAAM,CAAC;IACvC,UAAU,8PAAC,CAAC,MAAM;IAClB,iBAAiB,8PAAC,CAAC,MAAM;IACzB,cAAc,8PAAC,CAAC,MAAM,GAAG,QAAQ;IACjC,oBAAoB,8PAAC,CAAC,MAAM;IAC5B,YAAY,8PAAC,CAAC,MAAM;AACtB"}},
    {"offset": {"line": 147, "column": 0}, "map": {"version":3,"sources":["file:///Users/sudhir/Documents/vibe/error-saas/lib/normalize.ts"],"sourcesContent":["/**\n * Normalizes text according to the specification in master.md\n */\nexport function normalizeText(text: string): string {\n  // Limit length to 20,000 chars\n  let normalized = text.slice(0, 20000)\n  \n  // Lowercase\n  normalized = normalized.toLowerCase()\n  \n  // Strip ANSI color codes\n  // eslint-disable-next-line no-control-regex\n  normalized = normalized.replace(/\\x1b\\[[0-9;]*m/g, '')\n  \n  // Collapse whitespace\n  normalized = normalized.replace(/\\s+/g, ' ').trim()\n  \n  return normalized\n}"],"names":[],"mappings":"AAAA;;CAEC;;;;AACM,SAAS,cAAc,IAAY;IACxC,+BAA+B;IAC/B,IAAI,aAAa,KAAK,KAAK,CAAC,GAAG;IAE/B,YAAY;IACZ,aAAa,WAAW,WAAW;IAEnC,yBAAyB;IACzB,4CAA4C;IAC5C,aAAa,WAAW,OAAO,CAAC,mBAAmB;IAEnD,sBAAsB;IACtB,aAAa,WAAW,OAAO,CAAC,QAAQ,KAAK,IAAI;IAEjD,OAAO;AACT"}},
    {"offset": {"line": 169, "column": 0}, "map": {"version":3,"sources":["file:///Users/sudhir/Documents/vibe/error-saas/lib/matcher.ts"],"sourcesContent":["import { KubernetesError } from './schema'\nimport { normalizeText } from './normalize'\n\nexport interface MatchResult {\n  slug: string | null\n  confidence: number\n  score: number\n  matchDetails: MatchDetail[]\n  suggestions: Array<{\n    slug: string\n    title: string\n    category: string\n    score: number\n  }>\n}\n\nexport interface MatchDetail {\n  type: 'exact' | 'regex' | 'alias' | 'title' | 'summary' | 'cause' | 'semantic'\n  pattern: string\n  matchedText: string\n  score: number\n}\n\nexport interface MatcherConfig {\n  exactMatchWeight: number\n  regexWeight: number\n  aliasWeight: number\n  titleWeight: number\n  summaryWeight: number\n  causeWeight: number\n  semanticWeight: number\n  categoryBoost: Record<string, number>\n  lengthPenalty: boolean\n  fuzzyThreshold: number\n}\n\nclass K8MatcherEngine {\n  private config: MatcherConfig\n\n  constructor(config?: Partial<MatcherConfig>) {\n    this.config = {\n      exactMatchWeight: 50,\n      regexWeight: 25,\n      aliasWeight: 20,\n      titleWeight: 15,\n      summaryWeight: 10,\n      causeWeight: 8,\n      semanticWeight: 5,\n      categoryBoost: {\n        'runtime': 15,\n        'network': 12,\n        'auth': 10,\n        'storage': 10,\n        'config': 8,\n        'scheduler': 8,\n        'cluster': 8\n      },\n      lengthPenalty: true,\n      fuzzyThreshold: 0.7,\n      ...config\n    }\n  }\n\n  /**\n   * Matches normalized text against Kubernetes errors using weighted scoring\n   */\n  matchError(normalizedText: string, errors: KubernetesError[]): MatchResult {\n    if (!normalizedText.trim()) {\n      return {\n        slug: null,\n        confidence: 0,\n        score: 0,\n        matchDetails: [],\n        suggestions: []\n      }\n    }\n\n    const queryTokens = this.tokenize(normalizedText)\n    const results = errors.map(error => this.scoreError(normalizedText, queryTokens, error))\n    \n    // Sort by score descending\n    results.sort((a, b) => b.totalScore - a.totalScore)\n    \n    const topResult = results[0]\n    const confidence = this.calculateConfidence(topResult?.totalScore || 0, normalizedText.length)\n    \n    // Get top 5 suggestions\n    const suggestions = results.slice(0, 5).map(result => ({\n      slug: result.error.canonical_slug,\n      title: result.error.title,\n      category: result.error.category,\n      score: Math.round(result.totalScore * 10) / 10\n    }))\n\n    return {\n      slug: topResult?.error.canonical_slug || null,\n      confidence,\n      score: Math.round((topResult?.totalScore || 0) * 10) / 10,\n      matchDetails: topResult?.details || [],\n      suggestions\n    }\n  }\n\n  private scoreError(\n    normalizedText: string, \n    queryTokens: string[], \n    error: KubernetesError\n  ): { error: KubernetesError; totalScore: number; details: MatchDetail[] } {\n    const details: MatchDetail[] = []\n    let totalScore = 0\n\n    // 1. Exact canonical slug match\n    if (normalizedText === error.canonical_slug) {\n      const score = this.config.exactMatchWeight\n      details.push({\n        type: 'exact',\n        pattern: error.canonical_slug,\n        matchedText: normalizedText,\n        score\n      })\n      totalScore += score\n    }\n\n    // 2. Regex pattern matching\n    const regexScore = this.scoreRegexMatches(normalizedText, error.matchers.regex, details)\n    totalScore += regexScore\n\n    // 3. Alias matching\n    const aliasScore = this.scoreAliasMatches(normalizedText, queryTokens, error.aliases, details)\n    totalScore += aliasScore\n\n    // 4. Title matching\n    const titleScore = this.scoreTitleMatch(normalizedText, queryTokens, error.title, details)\n    totalScore += titleScore\n\n    // 5. Summary matching\n    const summaryScore = this.scoreSummaryMatch(normalizedText, queryTokens, error.summary, details)\n    totalScore += summaryScore\n\n    // 6. Root causes matching\n    const causeScore = this.scoreCauseMatches(normalizedText, queryTokens, error.root_causes, details)\n    totalScore += causeScore\n\n    // 7. Semantic/contextual matching\n    const semanticScore = this.scoreSemanticMatches(normalizedText, queryTokens, error, details)\n    totalScore += semanticScore\n\n    // 8. Category boost\n    const categoryBoost = this.config.categoryBoost[error.category] || 0\n    if (categoryBoost > 0) {\n      totalScore += categoryBoost\n      details.push({\n        type: 'semantic',\n        pattern: `category:${error.category}`,\n        matchedText: error.category,\n        score: categoryBoost\n      })\n    }\n\n    // 9. Length penalty for very short queries\n    if (this.config.lengthPenalty && normalizedText.length < 10) {\n      totalScore *= 0.8\n    }\n\n    return { error, totalScore, details }\n  }\n\n  private scoreRegexMatches(text: string, patterns: string[], details: MatchDetail[]): number {\n    let score = 0\n    const matchedPatterns = new Set<string>()\n\n    for (const pattern of patterns) {\n      try {\n        const regex = new RegExp(pattern, 'i')\n        const match = text.match(regex)\n        \n        if (match && !matchedPatterns.has(pattern)) {\n          matchedPatterns.add(pattern)\n          const matchScore = this.config.regexWeight * (1 + (match[0].length / text.length))\n          score += matchScore\n          \n          details.push({\n            type: 'regex',\n            pattern,\n            matchedText: match[0],\n            score: Math.round(matchScore * 10) / 10\n          })\n        }\n      } catch {\n        // Invalid regex, skip\n        continue\n      }\n    }\n\n    return score\n  }\n\n  private scoreAliasMatches(text: string, tokens: string[], aliases: string[], details: MatchDetail[]): number {\n    let score = 0\n    \n    for (const alias of aliases) {\n      const normalizedAlias = normalizeText(alias)\n      \n      // Exact alias match\n      if (text.includes(normalizedAlias)) {\n        const matchScore = this.config.aliasWeight * (normalizedAlias.length / text.length)\n        score += matchScore\n        \n        details.push({\n          type: 'alias',\n          pattern: alias,\n          matchedText: normalizedAlias,\n          score: Math.round(matchScore * 10) / 10\n        })\n      }\n      // Partial token matching\n      else {\n        const aliasTokens = this.tokenize(normalizedAlias)\n        const matchCount = tokens.filter(token => \n          aliasTokens.some(at => at.includes(token) || token.includes(at))\n        ).length\n        \n        if (matchCount > 0) {\n          const matchScore = (this.config.aliasWeight * 0.5) * (matchCount / Math.max(tokens.length, aliasTokens.length))\n          score += matchScore\n          \n          details.push({\n            type: 'alias',\n            pattern: alias,\n            matchedText: tokens.filter(t => aliasTokens.some(at => at.includes(t))).join(' '),\n            score: Math.round(matchScore * 10) / 10\n          })\n        }\n      }\n    }\n\n    return score\n  }\n\n  private scoreTitleMatch(text: string, tokens: string[], title: string, details: MatchDetail[]): number {\n    const normalizedTitle = normalizeText(title)\n    \n    if (text.includes(normalizedTitle) || normalizedTitle.includes(text)) {\n      const matchScore = this.config.titleWeight\n      details.push({\n        type: 'title',\n        pattern: title,\n        matchedText: title,\n        score: matchScore\n      })\n      return matchScore\n    }\n\n    // Token-based matching\n    const titleTokens = this.tokenize(normalizedTitle)\n    const matchCount = tokens.filter(token =>\n      titleTokens.some(tt => tt.includes(token) || token.includes(tt))\n    ).length\n\n    if (matchCount > 0) {\n      const matchScore = this.config.titleWeight * 0.7 * (matchCount / titleTokens.length)\n      details.push({\n        type: 'title',\n        pattern: title,\n        matchedText: tokens.filter(t => titleTokens.some(tt => tt.includes(t))).join(' '),\n        score: Math.round(matchScore * 10) / 10\n      })\n      return matchScore\n    }\n\n    return 0\n  }\n\n  private scoreSummaryMatch(text: string, tokens: string[], summary: string, details: MatchDetail[]): number {\n    const normalizedSummary = normalizeText(summary)\n    const summaryTokens = this.tokenize(normalizedSummary)\n    \n    const matchCount = tokens.filter(token =>\n      summaryTokens.some(st => st.includes(token) && token.length > 3)\n    ).length\n\n    if (matchCount > 0) {\n      const matchScore = this.config.summaryWeight * (matchCount / tokens.length)\n      details.push({\n        type: 'summary',\n        pattern: summary.slice(0, 50) + '...',\n        matchedText: tokens.filter(t => summaryTokens.some(st => st.includes(t))).join(' '),\n        score: Math.round(matchScore * 10) / 10\n      })\n      return matchScore\n    }\n\n    return 0\n  }\n\n  private scoreCauseMatches(text: string, tokens: string[], causes: any[], details: MatchDetail[]): number {\n    let score = 0\n    \n    for (const cause of causes.slice(0, 3)) { // Limit to top 3 causes\n      const causeText = normalizeText(`${cause.name} ${cause.why}`)\n      const causeTokens = this.tokenize(causeText)\n      \n      const matchCount = tokens.filter(token =>\n        causeTokens.some(ct => ct.includes(token) && token.length > 3)\n      ).length\n\n      if (matchCount > 0) {\n        const matchScore = this.config.causeWeight * (matchCount / tokens.length) * cause.confidence\n        score += matchScore\n        \n        details.push({\n          type: 'cause',\n          pattern: cause.name,\n          matchedText: tokens.filter(t => causeTokens.some(ct => ct.includes(t))).join(' '),\n          score: Math.round(matchScore * 10) / 10\n        })\n      }\n    }\n\n    return score\n  }\n\n  private scoreSemanticMatches(text: string, tokens: string[], error: KubernetesError, details: MatchDetail[]): number {\n    let score = 0\n    \n    // Common Kubernetes error keywords\n    const k8sKeywords = [\n      'pod', 'container', 'deployment', 'service', 'node', 'cluster',\n      'image', 'volume', 'secret', 'configmap', 'namespace', 'ingress',\n      'kubelet', 'api', 'scheduler', 'controller', 'etcd', 'proxy'\n    ]\n    \n    const contextKeywords = error.fix_steps\n      .flatMap(step => this.tokenize(step.step))\n      .filter(token => k8sKeywords.includes(token))\n      .slice(0, 5)\n    \n    const contextMatches = tokens.filter(token => contextKeywords.includes(token))\n    \n    if (contextMatches.length > 0) {\n      const matchScore = this.config.semanticWeight * contextMatches.length\n      score += matchScore\n      \n      details.push({\n        type: 'semantic',\n        pattern: 'kubernetes-context',\n        matchedText: contextMatches.join(' '),\n        score: Math.round(matchScore * 10) / 10\n      })\n    }\n\n    return score\n  }\n\n  private calculateConfidence(score: number, textLength: number): number {\n    // Base confidence from score\n    let confidence = 0\n    \n    if (score >= 80) {\n      confidence = 0.95\n    } else if (score >= 60) {\n      confidence = 0.85\n    } else if (score >= 40) {\n      confidence = 0.75\n    } else if (score >= 25) {\n      confidence = 0.65\n    } else if (score >= 15) {\n      confidence = 0.5\n    } else if (score >= 8) {\n      confidence = 0.35\n    } else {\n      confidence = 0.1\n    }\n    \n    // Adjust for text length\n    if (textLength < 20) {\n      confidence *= 0.8\n    } else if (textLength > 100) {\n      confidence *= 0.9\n    }\n    \n    return Math.min(confidence, 0.99)\n  }\n\n  private tokenize(text: string): string[] {\n    return text\n      .toLowerCase()\n      .replace(/[^\\w\\s]/g, ' ')\n      .split(/\\s+/)\n      .filter(token => token.length > 2)\n  }\n}\n\n// Create default matcher instance\nconst defaultMatcher = new K8MatcherEngine()\n\n/**\n * Legacy compatibility function\n */\nexport function matchError(normalizedText: string, errors: KubernetesError[]): MatchResult {\n  return defaultMatcher.matchError(normalizedText, errors)\n}\n\n/**\n * Create a custom matcher with specific configuration\n */\nexport function createMatcher(config: Partial<MatcherConfig>): K8MatcherEngine {\n  return new K8MatcherEngine(config)\n}\n\nexport { K8MatcherEngine }"],"names":[],"mappings":"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"}},
    {"offset": {"line": 487, "column": 0}, "map": {"version":3,"sources":["file:///Users/sudhir/Documents/vibe/error-saas/app/api/explain/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from 'next/server'\nimport { z } from 'zod'\nimport clientPromise from '@/lib/mongodb'\nimport { ErrorSchema, SubmissionSchema } from '@/lib/schema'\nimport { normalizeText } from '@/lib/normalize'\nimport { matchError } from '@/lib/matcher'\n\nconst RequestSchema = z.object({\n  text: z.string()\n})\n\nexport async function POST(request: NextRequest) {\n  try {\n    const body = await request.json()\n    const { text } = RequestSchema.parse(body)\n    \n    const client = await clientPromise\n    const db = client.db()\n    \n    // Get all Kubernetes errors\n    const errorsCollection = db.collection('errors')\n    const errors = await errorsCollection.find({ tool: 'kubernetes' }).toArray()\n    \n    // Validate errors against schema\n    const validErrors = errors\n      .map(error => {\n        try {\n          return ErrorSchema.parse(error)\n        } catch {\n          return null\n        }\n      })\n      .filter((error): error is NonNullable<typeof error> => error !== null)\n    \n    // Normalize input text\n    const normalizedText = normalizeText(text)\n    \n    // Match error\n    const matchResult = matchError(normalizedText, validErrors)\n    \n    // Save submission\n    const submission = {\n      raw_text: text,\n      normalized_text: normalizedText,\n      matched_slug: matchResult.slug,\n      matched_confidence: matchResult.confidence,\n      created_at: new Date().toISOString()\n    }\n    \n    await db.collection('submissions').insertOne(submission)\n    \n    // Get matched error details\n    let errorDetails = null\n    if (matchResult.slug) {\n      errorDetails = validErrors.find(e => e.canonical_slug === matchResult.slug)\n    }\n    \n    // Flatten sources from causes, steps, and examples\n    const allSources = errorDetails ? [\n      ...errorDetails.root_causes.flatMap(c => c.sources),\n      ...errorDetails.fix_steps.flatMap(s => s.sources),\n      ...errorDetails.examples.flatMap(e => e.sources)\n    ] : []\n    \n    // Remove duplicates\n    const uniqueSources = allSources.filter((source, index, self) => \n      index === self.findIndex(s => s.url === source.url)\n    )\n    \n    // Determine clarifying question\n    let clarifyingQuestion = null\n    if (matchResult.confidence < 0.6 && errorDetails) {\n      clarifyingQuestion = errorDetails.clarifying_questions[0] || \n        \"Can you provide more context about when this error occurs?\"\n    }\n    \n    return NextResponse.json({\n      tool: 'kubernetes',\n      match: {\n        slug: matchResult.slug,\n        confidence: matchResult.confidence\n      },\n      title: errorDetails?.title || null,\n      summary: errorDetails?.summary || null,\n      root_causes: errorDetails?.root_causes || [],\n      fix_steps: errorDetails?.fix_steps || [],\n      sources: uniqueSources,\n      clarifying_question: clarifyingQuestion,\n      suggestions: matchResult.confidence < 0.6 ? matchResult.suggestions : []\n    })\n    \n  } catch (error) {\n    console.error('API Error:', error)\n    return NextResponse.json(\n      { error: 'Failed to process request' },\n      { status: 500 }\n    )\n  }\n}"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAEA,MAAM,gBAAgB,8PAAC,CAAC,MAAM,CAAC;IAC7B,MAAM,8PAAC,CAAC,MAAM;AAChB;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,IAAI,EAAE,GAAG,cAAc,KAAK,CAAC;QAErC,MAAM,SAAS,MAAM,oJAAa;QAClC,MAAM,KAAK,OAAO,EAAE;QAEpB,4BAA4B;QAC5B,MAAM,mBAAmB,GAAG,UAAU,CAAC;QACvC,MAAM,SAAS,MAAM,iBAAiB,IAAI,CAAC;YAAE,MAAM;QAAa,GAAG,OAAO;QAE1E,iCAAiC;QACjC,MAAM,cAAc,OACjB,GAAG,CAAC,CAAA;YACH,IAAI;gBACF,OAAO,uJAAW,CAAC,KAAK,CAAC;YAC3B,EAAE,OAAM;gBACN,OAAO;YACT;QACF,GACC,MAAM,CAAC,CAAC,QAA8C,UAAU;QAEnE,uBAAuB;QACvB,MAAM,iBAAiB,IAAA,4JAAa,EAAC;QAErC,cAAc;QACd,MAAM,cAAc,IAAA,uJAAU,EAAC,gBAAgB;QAE/C,kBAAkB;QAClB,MAAM,aAAa;YACjB,UAAU;YACV,iBAAiB;YACjB,cAAc,YAAY,IAAI;YAC9B,oBAAoB,YAAY,UAAU;YAC1C,YAAY,IAAI,OAAO,WAAW;QACpC;QAEA,MAAM,GAAG,UAAU,CAAC,eAAe,SAAS,CAAC;QAE7C,4BAA4B;QAC5B,IAAI,eAAe;QACnB,IAAI,YAAY,IAAI,EAAE;YACpB,eAAe,YAAY,IAAI,CAAC,CAAA,IAAK,EAAE,cAAc,KAAK,YAAY,IAAI;QAC5E;QAEA,mDAAmD;QACnD,MAAM,aAAa,eAAe;eAC7B,aAAa,WAAW,CAAC,OAAO,CAAC,CAAA,IAAK,EAAE,OAAO;eAC/C,aAAa,SAAS,CAAC,OAAO,CAAC,CAAA,IAAK,EAAE,OAAO;eAC7C,aAAa,QAAQ,CAAC,OAAO,CAAC,CAAA,IAAK,EAAE,OAAO;SAChD,GAAG,EAAE;QAEN,oBAAoB;QACpB,MAAM,gBAAgB,WAAW,MAAM,CAAC,CAAC,QAAQ,OAAO,OACtD,UAAU,KAAK,SAAS,CAAC,CAAA,IAAK,EAAE,GAAG,KAAK,OAAO,GAAG;QAGpD,gCAAgC;QAChC,IAAI,qBAAqB;QACzB,IAAI,YAAY,UAAU,GAAG,OAAO,cAAc;YAChD,qBAAqB,aAAa,oBAAoB,CAAC,EAAE,IACvD;QACJ;QAEA,OAAO,ySAAY,CAAC,IAAI,CAAC;YACvB,MAAM;YACN,OAAO;gBACL,MAAM,YAAY,IAAI;gBACtB,YAAY,YAAY,UAAU;YACpC;YACA,OAAO,cAAc,SAAS;YAC9B,SAAS,cAAc,WAAW;YAClC,aAAa,cAAc,eAAe,EAAE;YAC5C,WAAW,cAAc,aAAa,EAAE;YACxC,SAAS;YACT,qBAAqB;YACrB,aAAa,YAAY,UAAU,GAAG,MAAM,YAAY,WAAW,GAAG,EAAE;QAC1E;IAEF,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,cAAc;QAC5B,OAAO,ySAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAA4B,GACrC;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}